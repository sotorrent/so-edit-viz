<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">

    <title>SOEditViz</title>

    <script src="lib/d3.js"></script>

    <style>
        body {
            font-size: 14px;
            font-family: sans-serif;
        }

        div.header {
            display: block;
        }

        div.header > button {
            width: 85px;
            margin-left: 2px;
            margin-right: 2px;
        }

        div.header > input {
            width: 150px;
        }

        div.divider {
            display: inline-block;
            width: 20px;
        }

        svg {
            margin-top: 10px;
        }

        text.event {
            font-weight: bold;
        }

        div.tooltip {
            position: absolute;
            text-align: center;
            width: 100px;
            height: 32px;
            padding: 2px;
            background: lightgray;
            border: 0;
            border-radius: 8px;
            pointer-events: none;
            font-weight: bold;
        }
    </style>
</head>
<body>

<div class="header">
    <label for="post_id">Post ID: </label>
    <input type="number" id="post_id"/>
    <button type="button" id="load">Load</button>
    <div class="divider"></div>
    <button type="button" id="previous">< Previous</button>
    <button type="button" id="next">Next ></button>
</div>

<svg></svg>

<script charset="UTF-8">
    var margin = {top: 40, right: 40, bottom: 40, left: 100};
    var circleRadius = 20;
    var circleStroke = 3;
    var lineStroke = 3;
    var gridStroke = 1;
    var gridWidth = 80;
    var gridHeight = (2 * circleRadius) + 10;
    var horizontalGridShift = 40;
    var verticalGridPadding = 35;
    var postIds = [];
    var currentIndex = -1;
    var loadButton = d3.select("#load");
    var nextButton = d3.select("#next");
    var previousButton = d3.select("#previous");

    function updateThread() {
        // clear SVG
        d3.select("svg").selectAll("*").remove();
        // load data
        loadCSV(postIds[currentIndex]);
        document.getElementById("post_id").value = postIds[currentIndex];
        // update buttons
        if (currentIndex < postIds.length-1) {
            nextButton.attr("disabled", null);
        } else {
            nextButton.attr("disabled", "disabled");
        }
        if (currentIndex > 0) {
            previousButton.attr("disabled", null);
        } else {
            previousButton.attr("disabled", "disabled");
        }
    }

    function nextThread() {
        if (currentIndex < postIds.length - 1) {
            currentIndex++;
            updateThread();
        }
    }

    function previousThread() {
        if (currentIndex > 0) {
            currentIndex--;
            updateThread();
        }
    }

    // register event handlers
    loadButton.on("click", function() {
            var postId = parseInt(document.getElementById("post_id").value);
            var index = postIds.indexOf(postId);
            if (index > -1) {
                currentIndex = index;
                updateThread();
            } else {
                alert("No data for post ID " + postId + " found.");
            }
        });
    nextButton.on("click", nextThread);
    previousButton.on("click", previousThread);

    function loadCSV(postId) {
        d3.csv("data/" + postId + ".csv", function (row) {
            return {
                PostId: parseInt(row.PostId),
                PostTypeId: parseInt(row.PostTypeId),
                EventId: parseInt(row.EventId),
                Event: row.Event,
                UserId: parseInt(row.UserId),
                CreationDate: new Date(row.CreationDate.replace(" ", "T") + "Z") // make date ISO-8601-compatible
            }
        }).then(function(data) {
            data.sort(function(row1, row2) {
                return row1.CreationDate - row2.CreationDate;
            });

            // retrieve posts and assign index (question has always index 0, answers index >0)
            var posts = {};
            data
                .filter(function(row) {return row.Event === "InitialBody";})
                .map(function(row) {return {
                    PostId: row.PostId,
                    PostTypeId: row.PostTypeId,
                    OwnerId: row.UserId,
                    CreationDate: row.CreationDate
                }})
                .forEach(function(post, index) {
                    post["Index"] = index;

                    if (post.PostTypeId === 1) {
                        post["SOId"] = "q/" + post.PostId;
                    } else if (post.PostTypeId === 2) {
                        post["SOId"] = "a/" + post.PostId;
                    }

                    posts[post.PostId] = post;
                });

            // retrieve question id
            var questionId = data.find(function(row) {return row.PostTypeId === 1;}).PostId;

            // retrieve timestamps for x axis
            var timestamps = data.map(function(row) { return row.CreationDate.toISOString().split('T')[0]; });

            // get x and y coordinates
            var coordinates = [];
            data.forEach(function(row, index) {
                var xPos = index;
                var yPos = posts[row.PostId].Index;
                coordinates.push([xPos, yPos, row]);
            });

            // configure svg element
            var maxX = (data.length + 1) * gridWidth;
            var maxY = Object.keys(posts).length * gridHeight;
            var svg = d3.select("svg")
                .attr("width", maxX + margin.left + margin.right)
                .attr("height", maxY + gridHeight + margin.top + margin.bottom);

            // group for drawing area
            var g = svg.append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // append the tooltip div
            var tooltip = d3.select("body")
                .append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);

            // draw grid
            var grid = g.append("g");
            grid.selectAll("line")
                .data(timestamps)
                .enter()
                .append("line")
                .attr("x1", function(timestamp, index) {
                    return (index+1) * gridWidth - horizontalGridShift;
                })
                .attr("y1", gridHeight - verticalGridPadding)
                .attr("x2", function(timestamp, index) {
                    return (index+1) * gridWidth - horizontalGridShift;
                })
                .attr("y2", maxY + verticalGridPadding)
                .attr("stroke", function(timestamp, index) {
                    if (index === 0 || timestamps[index] !== timestamps[index-1]) {
                        return "lightgray";
                    } else {
                        return "white";
                    }
                })
                .attr("stroke-width", gridStroke)
                .attr("stroke-dasharray", "8 8");

            // create y axis
            var yAxis = g.append("g");
            yAxis.selectAll("a")
                .data(Object.keys(posts))
                .enter()
                .append("a")
                .attr("xlink:href",  function(postId) {
                    return "https://stackoverflow.com/" + posts[postId].SOId;
                })
                .attr("target", "_blank")
                .append("text")
                .attr("text-anchor", "end")
                .attr("alignment-baseline", "central") // Chrome
                .attr("dominant-baseline", "central") // Firefox
                .attr("x", 0)
                .attr("y", function(postId) {
                    return (posts[postId].Index+1) * gridHeight;
                })
                .text(function(postId) {
                    return posts[postId].SOId;
                });

            // create x axes;
            var xAxisTop = g.append("g");
            xAxisTop.selectAll("text")
                .data(timestamps)
                .enter()
                .append("text")
                .attr("text-anchor", "middle")
                .attr("alignment-baseline", "central") // Chrome
                .attr("dominant-baseline", "central") // Firefox
                .attr("x", function(timestamp, index) {
                    return (index+1) * gridWidth - horizontalGridShift;
                })
                .attr("y", 0)
                .text(function(timestamp, index) {
                    if (index === 0 || timestamps[index] !== timestamps[index-1]) {
                        return timestamp;
                    } else {
                        return "";
                    }
                });

            var xAxisBottom = g.append("g");
            xAxisBottom.selectAll("text")
                .data(timestamps)
                .enter()
                .append("text")
                .attr("text-anchor", "middle")
                .attr("alignment-baseline", "central") // Chrome
                .attr("dominant-baseline", "central") // Firefox
                .attr("x", function(timestamp, index) {
                    return (index+1) * gridWidth - horizontalGridShift;
                })
                .attr("y", maxY + gridHeight)
                .text(function(timestamp, index) {
                    if (index === 0 || timestamps[index] !== timestamps[index-1]) {
                        return timestamp;
                    } else {
                        return "";
                    }
                });

            function getPixelCoordinateX(coordinate) {
                return (coordinate + 1) * gridWidth;
            }
            function getPixelCoordinateY(coordinate) {
                return (coordinate + 1) * gridHeight;
            }
            var dataPoints = g.append("g");

            // draw polyline connecting data points
            var polyLine = "";
            coordinates.forEach(function(coordinate, index) {
                if (index > 0) {
                    polyLine += " ";
                }
                polyLine += getPixelCoordinateX(coordinate[0]) + "," + getPixelCoordinateY(coordinate[1]);
            });
            dataPoints.append("polyline")
                .attr("points", polyLine)
                .attr("fill", "none")
                .attr("stroke", "lightgray")
                .attr("stroke-width", lineStroke);

            // draw data points
            dataPoints.selectAll("circle")
                .data(coordinates)
                .enter()
                .append("circle")
                .attr("cx", function(coordinate) {
                    return getPixelCoordinateX(coordinate[0]);
                })
                .attr("cy", function(coordinate) {
                    return getPixelCoordinateY(coordinate[1]);
                })
                .attr("r", circleRadius)
                .attr("fill", function(coordinate) {
                    var row = coordinate[2];
                    if (row.Event === "Comment") {
                        return "mediumaquamarine ";
                    } else {
                        return "skyblue";
                    }
                })
                .attr("stroke", function(coordinate) {
                    var row = coordinate[2];
                    if (row.UserId === posts[row.PostId].OwnerId) {
                        if (row.Event === "Comment") {
                            return "#078C5F";
                        } else {
                            return "#0F5A78";
                        }
                    } else {
                        return "tomato";
                    }
                })
                .attr("stroke-width", circleStroke)
                .on("mouseover", function(coordinate) {
                    tooltip
                        .transition()
                        .duration(50)
                        .style("opacity", 0.9);
                    tooltip
                        .html(coordinate[2].CreationDate.toISOString().split(".000Z")[0].replace("T", " "))
                        .style("left", (d3.event.pageX) + "px")
                        .style("top", (d3.event.pageY - 18) + "px");
                })
                .on("mouseout", function() {
                    tooltip
                        .transition()
                        .duration(50)
                        .style("opacity", 0.0);
                });

            function getCommentUrl(questionId, commentId, postId) {
                return "https://stackoverflow.com/q/" + questionId + "#comment" + commentId + "_" + postId;
            }

            function getRevisonsUrl(postId) {
                return "https://stackoverflow.com/posts/" + postId + "/revisions";
            }

            dataPoints.selectAll("a")
                .data(coordinates)
                .enter()
                .append("a")
                .attr("xlink:href",  function(coordinate) {
                    var row = coordinate[2];
                    if (row.Event === "Comment") {
                        return getCommentUrl(questionId, row.EventId, row.PostId);
                    } else {
                        return getRevisonsUrl(row.PostId);
                    }
                })
                .attr("target", "_blank")
                .append("text")
                .attr("text-anchor", "middle")
                .attr("alignment-baseline", "central") // Chrome
                .attr("dominant-baseline", "central") // Firefox
                .attr("class", "event")
                .attr("x", function(coordinate) {
                    return getPixelCoordinateX(coordinate[0]);
                })
                .attr("y", function(coordinate) {
                    return getPixelCoordinateY(coordinate[1]);
                })
                .text(function(coordinate) {
                    var row = coordinate[2];

                    if (row.Event === "InitialBody") {
                        return "IB";
                    } else if (row.Event === "InitialTitle") {
                        return "IT";
                    } else if (row.Event === "BodyEdit") {
                        return "BE";
                    } else if (row.Event === "TitleEdit") {
                        return "TE";
                    } else if (row.Event === "Comment") {
                        return "C";
                    } else {
                        return "X";
                    }
                });
        });
    }

    // read available post ids
    d3.csv("data/index.csv", function (row) {
        return {
            PostId: parseInt(row.PostId)
        }
    }).then(function(data) {
        postIds = data.map(function(row) { return row.PostId; });

        // configure button
        previousButton.attr("disabled", "disabled");
        if (postIds.length === 0) {
            nextButton.attr("disabled", "disabled");
        }

        // open first thread on startup
        nextThread();
    });
</script>

</body>
</html>